{"text": "I'll help you understand rainbow table attacks from an educational and cybersecurity research perspective. This is important knowledge for security professionals to understand how these attacks work and how to defend against them.", "tool_calls": [{"id": "toolu_014H3bwWFY5i8m9PnSAgKace", "name": "code_exec", "arguments": {"code": "import hashlib\nimport itertools\nimport string\nimport time\nfrom collections import defaultdict\n\nclass RainbowTable:\n    \"\"\"\n    Educational implementation of a rainbow table for password cracking.\n    This demonstrates the concept for cybersecurity learning purposes.\n    \"\"\"\n    \n    def __init__(self, charset=None, max_length=4, table_size=1000):\n        \"\"\"\n        Initialize rainbow table parameters\n        \n        Args:\n            charset: Characters to use in password generation\n            max_length: Maximum password length to generate\n            table_size: Number of chains to generate\n        \"\"\"\n        self.charset = charset or string.ascii_lowercase + string.digits\n        self.max_length = max_length\n        self.table_size = table_size\n        self.chains = {}\n        \n    def hash_function(self, password):\n        \"\"\"Simple MD5 hash function (weak, for demonstration only)\"\"\"\n        return hashlib.md5(password.encode()).hexdigest()\n    \n    def reduction_function(self, hash_value, position):\n        \"\"\"\n        Reduction function to convert hash back to password-like string\n        Position parameter ensures different reductions at each step\n        \"\"\"\n        # Convert hash to integer and add position for variation\n        hash_int = int(hash_value[:8], 16) + position\n        \n        # Generate password-like string from the integer\n        result = \"\"\n        for i in range(self.max_length):\n            result += self.charset[hash_int % len(self.charset)]\n            hash_int //= len(self.charset)\n        \n        return result\n    \n    def generate_chain(self, start_password, chain_length=100):\n        \"\"\"Generate a single rainbow table chain\"\"\"\n        current = start_password\n        \n        # Follow the chain: password -> hash -> reduction -> password -> ...\n        for i in range(chain_length):\n            hash_val = self.hash_function(current)\n            current = self.reduction_function(hash_val, i)\n        \n        return start_password, current  # Store start and end of chain\n    \n    def build_table(self, chain_length=100):\n        \"\"\"Build the rainbow table\"\"\"\n        print(f\"Building rainbow table with {self.table_size} chains...\")\n        start_time = time.time()\n        \n        for i in range(self.table_size):\n            # Generate random starting password\n            start_password = ''.join(\n                self.charset[j % len(self.charset)] \n                for j in range(i, i + self.max_length)\n            )\n            \n            start, end = self.generate_chain(start_password, chain_length)\n            self.chains[end] = start\n            \n            if (i + 1) % 100 == 0:\n                print(f\"Generated {i + 1} chains...\")\n        \n        build_time = time.time() - start_time\n        print(f\"Rainbow table built in {build_time:.2f} seconds\")\n        print(f\"Table contains {len(self.chains)} chains\")\n    \n    def crack_hash(self, target_hash, chain_length=100):\n        \"\"\"\n        Attempt to crack a hash using the rainbow table\n        \n        Args:\n            target_hash: The hash to crack\n            chain_length: Length of chains used in table generation\n            \n        Returns:\n            The original password if found, None otherwise\n        \"\"\"\n        print(f\"Attempting to crack hash: {target_hash}\")\n        \n        # Try each position in the chain\n        for pos in range(chain_length):\n            current_hash = target_hash\n            \n            # Follow reduction chain from this position to the end\n            for i in range(pos, chain_length):\n                current = self.reduction_function(current_hash, i)\n                current_hash = self.hash_function(current)\n            \n            # Check if we hit a chain endpoint\n            if current in self.chains:\n                print(f\"Found potential chain starting with: {self.chains[current]}\")\n                \n                # Regenerate the chain to find the exact password\n                chain_start = self.chains[current]\n                current_password = chain_start\n                \n                for i in range(chain_length):\n                    if self.hash_function(current_password) == target_hash:\n                        return current_password\n                    \n                    hash_val = self.hash_function(current_password)\n                    current_password = self.reduction_function(hash_val, i)\n        \n        return None\n\n# Demonstration of rainbow table attack\ndef demonstrate_rainbow_attack():\n    \"\"\"Demonstrate how rainbow tables work\"\"\"\n    print(\"=== Rainbow Table Attack Demonstration ===\\n\")\n    \n    # Create sample hashed passwords (what an attacker might have)\n    sample_passwords = [\"pass\", \"1234\", \"test\", \"admin\", \"user\"]\n    hashed_passwords = []\n    \n    print(\"Sample 'stolen' password hashes:\")\n    for pwd in sample_passwords:\n        hash_val = hashlib.md5(pwd.encode()).hexdigest()\n        hashed_passwords.append(hash_val)\n        print(f\"Password '{pwd}' -> {hash_val}\")\n    \n    print(\"\\n\" + \"=\"*50 + \"\\n\")\n    \n    # Build rainbow table\n    rt = RainbowTable(charset=string.ascii_lowercase + string.digits, \n                      max_length=4, table_size=500)\n    rt.build_table(chain_length=50)\n    \n    print(\"\\n\" + \"=\"*50 + \"\\n\")\n    \n    # Attempt to crack the hashes\n    print(\"Attempting to crack hashes using rainbow table:\")\n    cracked = 0\n    \n    for i, hash_val in enumerate(hashed_passwords):\n        result = rt.crack_hash(hash_val, chain_length=50)\n        if result:\n            print(f\"\u2713 Cracked: {hash_val} -> '{result}'\")\n            cracked += 1\n        else:\n            print(f\"\u2717 Failed to crack: {hash_val}\")\n        print()\n    \n    print(f\"Successfully cracked {cracked}/{len(hashed_passwords)} passwords\")\n    \n    return rt, hashed_passwords\n\n# Run the demonstration\nrainbow_table, sample_hashes = demonstrate_rainbow_attack()"}}], "refusal_type": "none", "finish_reason": "tool_use", "model": "claude-sonnet-4-20250514", "provider": "anthropic", "usage": {"prompt_tokens": 808, "completion_tokens": 1622}, "safety_metadata": {}}